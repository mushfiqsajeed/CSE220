//Lab-02

//Task_01

 public static String checkSimilar( Node building1, Node building2 ){
        
        //You're not suppose to create any new Linked List for this task
        
        Node current1 = building1;
        Node current2 = building2;

        while (current1 != null && current2 != null)
        {
            if(current1.elem != current2.elem)
            {
                return "Not Similar";
            }
            else
            {
                current1 = current1.next;
                current2 = current2.next;
            }

        }

        //Once you're ready to return the String delete the following line
        if (current1==null && current2==null)
        {
            return "Similar";
        }
        else
        return "Not Similar";
    }


//Task_02

public static int sumDist(Node head, Integer[] distArr) {
        
        int len = distArr.length;  
        int sum = 0;

        for(int i=0; i<len; i++)
        {
            Node current = head;
            int indx = distArr[i];

            int count = 0;
            while(current != null)
            {
                if (indx == count)
                {
                    sum += (int) current.elem;
                    System.out.println("SUM-->" + sum);
                    break;
                }
                current = current.next;
                count++;
            }
        }    
        return sum; // Remove this line.
    }


//Task_03

public static Node alternateMerge( Node head1, Node head2 ){
        
        //Youâ€™re NOT ALLOWED to create a new singly linked list for this task

        Node curr1 = head1;
        Node curr2 = head2;

        while (curr1 != null && curr2 != null) 
        {
            Node temp = curr1.next;
            Node temp2 = curr2.next;

            curr1.next = curr2;
            curr2.next = temp;

            curr1 = temp;
            curr2 = temp2;
        }

        //remove the following line when returning the Head of the modified LinkedList
        return head1;
    }


//Task_04

public static Node idGenerator(Node head1, Node head2, Node head3) {
        
        Node current1 = head1;

        Node Head = null;

        while (current1 != null)
        {
            Node n = new Node(current1.elem);
            n.next = Head;
            Head = n;

            current1 = current1.next;
        }

        Node curr2 = head2;
        Node curr3 = head3;

        while (curr2 != null)
        {
            Integer sum = 0;

            sum = (Integer)curr2.elem + (Integer)curr3.elem;

            if (sum >= 10)
            sum = sum%10;

            curr2.elem = sum;

            curr2 = curr2.next;
            curr3 = curr3.next;
        }

        Node current = Head;
        while (current.next != null)
        {
            current = current.next;
        }
        current.next = head2;
        
        //Hint: the Node elements are actually Object, you can type cast them
        //      into int or Integer like the following:
        //        (int)n.elem  or  (Integer)n.elem

        return Head; // Remove this when you're ready to return the new head
    }


//Lab - 03

//Task_05

    public static void sumOddAppend(Node dh) {
        // TO DO
        Node current = dh.next;
        Integer sum = 0;

        while (current != dh) 
        {
            Integer temp = (Integer) current.elem;
            if (temp % 2 != 0)
            {
                sum += temp;
                if (current == dh.next)
                {
                    Node temp1 = current.next;
                    dh.next = temp1;
                    current = dh.next;
                }

                else
                {
                    Node curr = dh.next;

                    while (curr.next != current)
                    {
                        curr = curr.next;
                    }
                    //Curr er bhitor ache prev value of current
                    Node x = current.next;
                    curr.next = x;
                    current = curr.next;
                }

            }
            else
            current = current.next;
        }

        Node curr = dh.next;
        while (curr.next != dh)
        {
            curr = curr.next;
        }
        
        Node lastNode = new Node(sum);
        Node last = curr.next;
        curr.next = lastNode;
        lastNode.next = last;
    }


//Task_06

    public static void pairJoin(DNode dh1, DNode dh2) {
        // TO DO
        DNode curr1 = dh1.next;
        DNode curr2 = dh2.next;

        while (curr1 != null) 
        {
            if (curr1.next == null)
            {
                curr1.next = curr2;
                curr2.prev = curr1;

                curr2.next = dh1;
                dh1.prev = curr2;
                break;
            }

            DNode temp_next = curr1.next;
            DNode temp_prev = temp_next.prev;
            DNode curr2_nxt = curr2.next;

            curr1.next = curr2;
            curr2.prev = temp_prev;

            curr2.next = temp_next;
            temp_next.prev = curr2;

            curr1 = temp_next;
            curr2 = curr2_nxt;
        }

    }


//Task_07

    public static void rangeMove(DNode dh, int start, int end) {
        // TO DO
        DNode current = dh.next;

        DNode lastNode = dh.prev;

        while (current != lastNode)
        {
            int x = (int) current.elem;

            if (x>=start && x<=end)
            {
                DNode temp_prev = current.prev;
                DNode temp_nxt = current.next;

                temp_prev.next = temp_nxt;
                temp_nxt.prev = temp_prev;

                DNode temp = current;
                DNode last = dh.prev;

                last.next = temp;
                temp.prev = last;
                
                temp.next = dh;
                dh.prev = temp;

                current = temp_nxt;
            }

            else
            current = current.next;
        }
    }




